<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.53">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>TS 类型推断 | curryPaste`s VuePress ！</title><meta name="description" content="用VuePress偷懒整的一个站点">
    <link rel="preload" href="/ssVuePress/assets/style.047e36a0.css" as="style" /><link rel="stylesheet" href="/ssVuePress/assets/style.047e36a0.css" />
    <link rel="modulepreload" href="/ssVuePress/assets/app.4f2cb50a.js"><link rel="modulepreload" href="/ssVuePress/assets/index.html.05aa18bc.js"><link rel="modulepreload" href="/ssVuePress/assets/index.html.b8e70076.js"><link rel="prefetch" href="/ssVuePress/assets/index.html.fd461015.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.583732f3.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.b95d9b5b.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.5a77ed6e.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.b0a213bf.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.61c4bf87.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.58aa6199.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.a06c8a64.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.ba70a2ab.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.80676b04.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.d1fb18d7.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.f72757e4.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.0b90c876.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.a53abac7.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.4c0a0998.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.670d3834.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.211e1a69.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.d2aca67e.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.0255967a.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.0e15807f.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.e87d03c5.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.1242f4ad.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.cd74b23e.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.0506f624.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.7743f7e8.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.6b0b739e.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.dc5e4c39.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.a0b1817a.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.472d1f18.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.37087dbd.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/404.html.c3e557d0.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.253ebb2c.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.12a6f32a.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.7b01aa37.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.ec7e63f1.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.0ee45185.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.21fe840c.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.4e40b029.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.0eefbe1c.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.e0fbe8de.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.4262cef8.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.39fa2426.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.fd14571d.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.affe9340.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.e3b2e814.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.45fd6241.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.29d75764.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.9d65125d.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.00b5798a.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.31a75453.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.5f1bc545.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.7176fcd0.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.2e0f1ad3.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.aceb9abc.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.8db84a1c.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.eab7b839.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.e86d5991.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.7f5ac601.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.b1832e46.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.72898a97.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/index.html.0ad85bf8.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/404.html.6de86c8f.js" as="script" /><link rel="prefetch" href="/ssVuePress/assets/giscus.468808e8.js" as="script" />
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/ssVuePress/" class=""><img class="logo" src="https://avatars.githubusercontent.com/u/51729441?s=96&amp;v=4" alt="curryPaste`s VuePress ！"><span class="site-name can-hide">curryPaste`s VuePress ！</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><!----><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><!----><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/ssVuePress/" class="sidebar-item sidebar-heading" aria-label="CurryPaste"><!--[--><!--]--> CurryPaste <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/htmlCss" class="sidebar-item sidebar-heading" aria-label="HTML 与 CSS"><!--[--><!--]--> HTML 与 CSS <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a href="/ssVuePress/htmlCss/cssMixedMode" class="sidebar-item" aria-label="css混合模式"><!--[--><!--]--> css混合模式 <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/htmlCss/cssAndJsAnimation" class="sidebar-item" aria-label="css和js的动画比较"><!--[--><!--]--> css和js的动画比较 <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/htmlCss/bfc" class="sidebar-item" aria-label="什么是BFC"><!--[--><!--]--> 什么是BFC <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/htmlCss/echarts" class="sidebar-item" aria-label="Echarts"><!--[--><!--]--> Echarts <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/ssVuePress/jsTs" class="router-link-active sidebar-item sidebar-heading" aria-label="JS 与 TS"><!--[--><!--]--> JS 与 TS <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a href="/ssVuePress/jsTs/proto_prototype" class="sidebar-item" aria-label="js 原型与原型链"><!--[--><!--]--> js 原型与原型链 <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/jsTs/require_import_diff" class="sidebar-item" aria-label="JS中 require 和 import 区别"><!--[--><!--]--> JS中 require 和 import 区别 <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/jsTs/call_apply_bind" class="sidebar-item" aria-label="js中的call、apply、bind"><!--[--><!--]--> js中的call、apply、bind <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/jsTs/scope_context" class="sidebar-item" aria-label="作用域与上下文"><!--[--><!--]--> 作用域与上下文 <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/jsTs/deepCopy_shallowCopy" class="sidebar-item" aria-label="深拷贝和浅拷贝"><!--[--><!--]--> 深拷贝和浅拷贝 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/ssVuePress/jsTs/ts_typeInference" class="router-link-active router-link-exact-active router-link-active sidebar-item" aria-label="TS类型推断"><!--[--><!--]--> TS类型推断 <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/jsTs/nodeJsV12" class="sidebar-item" aria-label="nodeJsV12"><!--[--><!--]--> nodeJsV12 <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/jsTs/ts_type_interface_diff" class="sidebar-item" aria-label="TS: type 和 interface 的区别"><!--[--><!--]--> TS: type 和 interface 的区别 <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/jsTs/npx_npm_cnpm_pnpm_diff" class="sidebar-item" aria-label="npx、npm、cnpm、pnpm的区别"><!--[--><!--]--> npx、npm、cnpm、pnpm的区别 <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/jsTs/js_array_reduce_examples" class="sidebar-item" aria-label="js数组方法reduce经典用法代码分享"><!--[--><!--]--> js数组方法reduce经典用法代码分享 <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/jsTs/vue_import_img_require" class="sidebar-item" aria-label="vue中动态引入图片为什么要是require"><!--[--><!--]--> vue中动态引入图片为什么要是require <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/jsTs/react_hooks_linkedList" class="sidebar-item" aria-label="React hooks 的基础概念：hooks链表"><!--[--><!--]--> React hooks 的基础概念：hooks链表 <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/jsTs/js_use_strict" class="sidebar-item" aria-label="JavaScript中的严格模式"><!--[--><!--]--> JavaScript中的严格模式 <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/jsTs/emoji_form_programming_perspective" class="sidebar-item" aria-label="为什么 […‘👩‍❤️‍💋‍👨’] 在 JavaScript 中返回 [‘👩’, ‘‍’, ‘❤’, ‘️’, ‘‍’, ‘💋’, ‘‍’, ‘👨’]？"><!--[--><!--]--> 为什么 […‘👩‍❤️‍💋‍👨’] 在 JavaScript 中返回 [‘👩’, ‘‍’, ‘❤’, ‘️’, ‘‍’, ‘💋’, ‘‍’, ‘👨’]？ <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/ssVuePress/http" class="sidebar-item sidebar-heading" aria-label="Http 与 网络协议"><!--[--><!--]--> Http 与 网络协议 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a href="/ssVuePress/http/http_cache" class="sidebar-item" aria-label="http缓存"><!--[--><!--]--> http缓存 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/ssVuePress/applet" class="sidebar-item sidebar-heading" aria-label="小程序 - 跨平台"><!--[--><!--]--> 小程序 - 跨平台 <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/app" class="sidebar-item sidebar-heading" aria-label="App - 跨平台"><!--[--><!--]--> App - 跨平台 <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/algorithm" class="sidebar-item sidebar-heading" aria-label="算法相关"><!--[--><!--]--> 算法相关 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a href="/ssVuePress/algorithm/recurrence_Hanoi" class="sidebar-item" aria-label="递归_汉诺塔"><!--[--><!--]--> 递归_汉诺塔 <!--[--><!--]--></a><!----></li><li><a href="/ssVuePress/algorithm/sort_quickSort" class="sidebar-item" aria-label="排序_快速排序法"><!--[--><!--]--> 排序_快速排序法 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/ssVuePress/lifeGossip" class="sidebar-item sidebar-heading" aria-label="生活杂项"><!--[--><!--]--> 生活杂项 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a href="/ssVuePress/lifeGossip/why_game_recharge_amount_648" class="sidebar-item" aria-label="为什么游戏的充值金额都是648"><!--[--><!--]--> 为什么游戏的充值金额都是648 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="ts-类型推断" tabindex="-1"><a class="header-anchor" href="#ts-类型推断" aria-hidden="true">#</a> TS 类型推断</h1><p>在正式开始之前，先问一个问题，你知道在 Typescript（后面简称 TS）中有一个关键字用于推断类型么？是的这个关键字和本文的核心是一样的：<code>infer</code>。意如其字，<code>infer</code>就是推断，这个关键字就是用于推断类型。</p><h3 id="类型推断" tabindex="-1"><a class="header-anchor" href="#类型推断" aria-hidden="true">#</a> 类型推断</h3><p>类型推断在 TS 中其实无处不在，最简单的例子：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span> <span class="token comment">// typeof num === number</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在这里我们没有明确通过<code>const num: number</code>指定其类型，但是 TS 通过我们赋予其的初始值就可以确定其类型是 number，这就是最基础的类型推断。</p><p>同样如果我们声明一个函数：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// typeof num === number</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为我们的函数<code>fun</code>有明确的返回值<code>a + b</code>并且这两个参数都是<code>number</code>类型，可以明确确定函数的返回值就是<code>number</code>类型，所以即便我们没有明确写出<code>fun</code>的返回值<code>fun(): number</code>，但是 TS 会自动给我们推断出函数的返回类型是什么。</p><p>以上就是最基础的类型推断。</p><h3 id="infer-关键字" tabindex="-1"><a class="header-anchor" href="#infer-关键字" aria-hidden="true">#</a> infer 关键字</h3><p>那么既然 TS 已经这么强大能够推断出类型，那么为什么还需要<code>infer</code>关键字呢？答案就是，自动推断冉冉不够强大（废话）。毕竟编译器的能力仍然是有限的，不能指望所有情况都能帮助我们推断正确，尤其是 JS 这么灵活的语言，比如：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">logTuple</span><span class="token punctuation">(</span>tup<span class="token operator">:</span> <span class="token punctuation">{</span>tuple<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tup<span class="token punctuation">.</span>tuple<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tup<span class="token punctuation">.</span>tuple<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> myTuple <span class="token operator">=</span> <span class="token punctuation">{</span>tuple<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">logTuple</span><span class="token punctuation">(</span>myTuple<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>TS 会给我们一个错误.</p><p><code>Argument of type &#39;\{ tuple: string[]; \}&#39; is not assignable to parameter of type &#39;A&#39;.</code></p><p>这是因为在我们声明<code>myTuple</code>的时候，TS 就给我们推断了其类型，在 TS 眼中<code>[&#39;a&#39;, &#39;b&#39;]</code>对应的是<code>string[]</code>类型，而我们声明的<code>A</code>类型里面则对应的是<code>[string, string]</code>的<code>tuple</code>类型，所以这是无法对应上的。而直接<code>logTuple({tuple: [&#39;a&#39;, &#39;b&#39;]});</code>则又是可以的，这里就存在着参数类型推断的使用，我们会在后面的篇章中详细说，我们还是先关注失败的这种写法以及<code>infer</code>关键字。</p><p>那么这时候我们可以怎么解决这个问题呢？最简单的当然是把类型从参数中提出来，然后在声明<code>myTuple</code>的时候指定其类型来主动告知 TS：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  tuple<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> myTuple<span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">=</span> <span class="token punctuation">{</span>tuple<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">logTuple</span><span class="token punctuation">(</span>myTuple<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但这种方式有一个缺陷就是，如果logTuple函数并不是我们自己定义的，我们没法去修改其定义，那怎么办呢？</p><p>先直接说方案：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">GetFirstArgument<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>
  first<span class="token operator">:</span> <span class="token keyword">infer</span> FirstArgument<span class="token punctuation">,</span>
  <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span>
  <span class="token operator">?</span> FirstArgument
  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> myTuple<span class="token operator">:</span> GetFirstArgument<span class="token operator">&lt;</span><span class="token keyword">typeof</span> logTuple<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>tuple<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">logTuple</span><span class="token punctuation">(</span>myTuple<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这个工具类型，我们可以获取到<code>logTuple</code>的参数类型，进而指定<code>myTuple</code>为这个类型来解决这个问题。而这里我们就用到了<code>infer</code>这个关键字。那么事情是怎么发生的呢？</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">GetFirstArgument<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>
  first<span class="token operator">:</span> <span class="token keyword">infer</span> FirstArgument<span class="token punctuation">,</span>
  <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span>
  <span class="token operator">?</span> FirstArgument
  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>第一步：TS 判断我们赋予的 T 类型是否符合<code>extends</code>限定的类型，在这里是一个至少有一个参数的函数</li><li>第二步：一旦符合，则把这个 T 这个函数的第一个参数推断出来并且赋值给<code>FirstArgument</code></li><li>第三步：如果 T 符合该类型推断，则返回推断出来的<code>FirstArgument</code>类型，否则返回<code>never</code></li></ul><p>点击<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.coursebetter.com%2Ftools%2F2022%2Ftypescript-argument-type-inference" target="_blank" rel="noopener noreferrer">查看原文<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，原文这里有更丰富的组件进行代码讲解，更易于理解。</p><p>这是一个极其典型的通过泛型来进行类型推断的例子，而<code>infer</code>关键字在这里的意义则是推断出<code>T</code>函数签名的第一个参数的类型，以及把这个类型赋值给<code>FirstArgument</code>以便后续使用。</p><p>需要注意的是，<code>FirstArgument</code>是有作用域的，他只会存在于<code>GetFirstArgument</code>的推断周期内，如果我们在其他地方定义了同名的<code>FirstArgument</code>，并不会影响这里的<code>FirstArgument</code>。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">FirstArgument</span><span class="token operator">=</span> <span class="token builtin">string</span>

<span class="token keyword">type</span> <span class="token class-name">GetFirstArgument<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>first<span class="token operator">:</span> <span class="token keyword">infer</span> FirstArgument<span class="token punctuation">,</span> <span class="token operator">...</span> <span class="token comment">// 没有任何关系</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你仍然不理解，你可以把<code>GetFirstArgument</code>看作一个函数：</p><ul><li><code>T</code>是他的参数</li><li>我们在使用<code>GetFirstArgument</code>类型时，其实就是调用了这个函数，然后传入了<code>logTuple</code>作为参数<code>T</code></li><li>然后得到的是<code>=</code>后面得到的类型，这段代码非常像我们在 JS 中二元判断，条件判断内容是<code>T</code>是否符合某个类型，在这里的类型是<code>(first: infer FirstArgument,...args: any[]) =&gt; any</code>，也就是一个至少有一个参数的函数</li><li>只要我们在使用<code>GetFirstArgument</code>时候给的是这样的一个函数，那么推断条件就成立，就会得到一个推断的<code>FirstArgument</code>类型然后作为结果返回，否则就返回二元判断的另外一个结果</li></ul><p>而这个 TS 的函数则是在：<code>const a: GetFirstArgument&lt;(a: number) =&gt; void&gt;</code>时调用（不是真的如 JS 函数一样调用，只是进行类比）。</p><h2 id="update-2" tabindex="-1"><a class="header-anchor" href="#update-2" aria-hidden="true">#</a> update-2</h2><h3 id="参数类型推断" tabindex="-1"><a class="header-anchor" href="#参数类型推断" aria-hidden="true">#</a> 参数类型推断</h3><p>在开始讲参数推断之前，我们需要至少对 TS 的泛型（generics）有基本的理解，推荐大家至少去官网看一下文档 ：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2F2%2Fgenerics.html" target="_blank" rel="noopener noreferrer">文档地址<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>。</p><p>我这里做一个最简单直观的介绍，我们直接用官方文档的例子：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">wrapper</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span>inner<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    inner<span class="token operator">:</span> arg<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如这个函数，他帮助我们把传入的参数外包了一层，使之变成了一个对象。在这个定义里面，我们的入参只能是 number 类型的，但是从函数实现上来说，我们其实并没必要把这个类型限制这么死，我门希望这个函数可以支持更多的类型。这里有很多解决方案，比如我们可以把我们能想象到的类型写到定义上：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">wrapper</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">number</span> ｜ <span class="token builtin">string</span> <span class="token operator">|</span> Date<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span> inner<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span> <span class="token operator">|</span> Date <span class="token punctuation">}</span> <span class="token punctuation">{</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是这并不是很好，因为每次我们希望增加一种类型的支持，都需要重新修改函数的定义，并且我们得到的返回值的<code>inner</code>类型是不确定的，不论我们最终传入的是<code>number</code>还是<code>string</code>，你得到的返回值的inner都是定义中的所有可能性。</p><p>而泛型则就是用来简单地解决这个问题的，我们来看看泛型的用法：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">wrapper</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span>inner<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    inner<span class="token operator">:</span> arg<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里我们对于函数的定义上增加了<code>&lt;T&gt;</code>，而他就是泛型的关键。当我们使用这个函数的时候就会变成这样：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token generic-function"><span class="token function">wrapper</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这时候 TS 的编译器就会知道，你这次调用<code>wrapper</code>函数传入的是<code>number</code>类型，所以这次函数调用的返回值也是<code>{inner: number}</code>。</p><p>泛型就类似于针对 TS 定义的参数，通过在调用时指定类型，来动态地应用类型于函数定义。就像我们在 JS 中，函数的参数可以控制函数的运行结果一样，所以让我用一句话来定义就是：针对 TS 定义的参数。</p><p>OK，泛型的基础用法和理解就讲到这里，更多的用法还是去看官方文档吧。</p><h3 id="参数类型推断-type-argument-inference" tabindex="-1"><a class="header-anchor" href="#参数类型推断-type-argument-inference" aria-hidden="true">#</a> 参数类型推断（type argument inference）</h3><p>那么接下去我们就来聊聊本文的另一个重点：参数类型推断。在 TS 中，类型推断时非常常见的，比如：</p><p>类型推断同样可是使用在函数的泛型定义中，比如上面的例子：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">wrapper</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span>inner<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    inner<span class="token operator">:</span> arg<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如若我们在使用时直接<code>wrapper(1)</code>，这个函数也能正常使用，并且 TS 也能识别出返回的类型是<code>{inner: number}</code>。在这个过程中，TS 首先发现我们传递给<code>wrapper</code>函数的参数是<code>1</code>，是个 number 类型。继而发现<code>wrapper</code>函数接受泛型，因为整个函数只有一个泛型而且和入参的类型时一致的，所以 TS 可以反推出<code>&lt;T&gt;</code>就是<code>number</code>类型。而这个过程是在<code>wrapper(1)</code>调用的时候确定的，所以就很类似 JS 的函数。</p><p>参数类型推断非常有用，尤其是当入参的类型非常复杂的时候。典型的例子是 vue3 的<code>defineComponent</code>函数。</p><p><code>defineComponent</code>用于定义一个组件，而组件定义的配置内容的类型时非常复杂的：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token function">defineComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    props<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们需要在使用该函数的时候把整个配置的内容都定义出来，那么我们的代码量可能需要增加一倍，并且整个学习难度也自然会上升一些，毕竟你需要记住这些参数的类型。</p><p>我们可以看一下`defineComponeng 的定义：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">defineComponent</span><span class="token generic class-name"><span class="token operator">&lt;</span>
  PropsOptions <span class="token keyword">extends</span> Readonly<span class="token operator">&lt;</span>ComponentPropsOptions<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  RawBindings<span class="token punctuation">,</span>
  <span class="token constant">D</span><span class="token punctuation">,</span>
  <span class="token constant">C</span> <span class="token keyword">extends</span> ComputedOptions <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token constant">M</span> <span class="token keyword">extends</span> MethodOptions <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  Mixin <span class="token keyword">extends</span> ComponentOptionsMixin <span class="token operator">=</span> ComponentOptionsMixin<span class="token punctuation">,</span>
  Extends <span class="token keyword">extends</span> ComponentOptionsMixin <span class="token operator">=</span> ComponentOptionsMixin<span class="token punctuation">,</span>
  <span class="token constant">E</span> <span class="token keyword">extends</span> EmitsOptions <span class="token operator">=</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  <span class="token constant">EE</span> <span class="token keyword">extends</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token builtin">string</span>
<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>
  options<span class="token operator">:</span> ComponentOptionsWithObjectProps<span class="token operator">&lt;</span>
    PropsOptions<span class="token punctuation">,</span>
    RawBindings<span class="token punctuation">,</span>
    <span class="token constant">D</span><span class="token punctuation">,</span>
    <span class="token constant">C</span><span class="token punctuation">,</span>
    <span class="token constant">M</span><span class="token punctuation">,</span>
    Mixin<span class="token punctuation">,</span>
    Extends<span class="token punctuation">,</span>
    <span class="token constant">E</span><span class="token punctuation">,</span>
    <span class="token constant">EE</span>
  <span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token operator">:</span> DefineComponent<span class="token operator">&lt;</span>PropsOptions<span class="token punctuation">,</span> RawBindings<span class="token punctuation">,</span> <span class="token constant">D</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">,</span> <span class="token constant">M</span><span class="token punctuation">,</span> Mixin<span class="token punctuation">,</span> Extends<span class="token punctuation">,</span> <span class="token constant">E</span><span class="token punctuation">,</span> <span class="token constant">EE</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这还仅仅是一种函数签名，vue3 的<code>defineComponent</code>函数签名有 4 种 overrides，其复杂程度可想而知。索性有参数类型推断，让我们避免了每次使用都要写一堆复杂定义的烦恼。</p><p>我们只需要：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> Comp <span class="token operator">=</span> <span class="token function">defineComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> String<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们就知道<code>Comp</code>的 <code>props</code> 中有一个名为 <code>name</code> 的属性类型为 <code>String</code> 。</p><h3 id="extends" tabindex="-1"><a class="header-anchor" href="#extends" aria-hidden="true">#</a> extends</h3><p>我相信你已经注意到了在上面的 <code>defineComponents</code> 存在着非常多的 <code>extends</code> 。这又是 TS 中对于类型推断非常重要的一个字段。他的重要性体现在对鱼类型约束上。当你写 <code>function A&lt;T&gt;(opt: T): T</code> 的时候，这里的 <code>T</code> 可以是任意类型，所以你调用函数 <code>A(1)</code> 的时候， <code>T</code> 的类型又完全交还给 TS 来判断，比如之前的数组例子：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token constant">A</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>opt<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> opt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> tuple <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时候 <code>tuple</code> 会是 <code>string[]</code> 类型，而不是我们期望的 <code>[string, string]</code> 类型。这时候我们就可以给 <code>T</code> 一个约束：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token constant">A</span><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>opt<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> opt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> tuple <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时我们的 <code>tuple</code> 就会是 <code>[string, string]</code> ，我们给 <code>T</code> 约束为 <code>string</code> 类型的 tuple，TS 就会在类型推断的时候有限匹配约束的类型，如果类型无法匹配则会报错。</p><p>类型约束在类型推断中是非常有用的，事实上你应该尽量在使用泛型时赋予一个约束，这能够帮助我们更精确的得到自己想要的类型，你可以回过头去看 vue3 的 <code>difineComponent</code> ，几乎所有的泛型都是用 <code>extends</code> 来进行类型约束。</p><h3 id="实例讲解" tabindex="-1"><a class="header-anchor" href="#实例讲解" aria-hidden="true">#</a> 实例讲解</h3><p>最后我们通过一个例子再来展示一下参数类型推断的作用，假如有如下的场景：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">defineStore</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> options<span class="token punctuation">;</span> <span class="token comment">// 你创建的store</span>
<span class="token punctuation">}</span>

<span class="token function">defineStore</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  actions<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>commits<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> commits<span class="token punctuation">.</span>a<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  commits<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>state<span class="token punctuation">,</span> newName<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  state<span class="token operator">:</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">&#39;jokcy&#39;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们想要创建一个定义 <code>store</code> 的函数，这个定义比较类似 vuex，我们分成 <code>state/actions/commits</code> 三部分，在每个 <code>commit</code> 函数中我们会接收 <code>state</code> 作为第一个参数，便于我们更新数据；在每个 <code>action</code> 中我们接受所有 <code>commits</code> 作为参数，这样我们在 <code>action</code> 中可以进行数据更新。</p><p>那么为了更好的体验，我们自然希望每个 <code>commit</code> 中拿到的 <code>state</code> 可以知道其类型，同样在每个 <code>action</code> 中也知道所有 <code>commit</code> 的函数签名，这样我们调用 <code>commit</code> 的时候就知道要传哪些参数，TS 也可以帮我们在代码检测帮我们定为错误。我们可以这么做：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">MyCommits</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">MyState</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>

a<span class="token operator">:</span> <span class="token punctuation">(</span>commits<span class="token operator">:</span> MyCommits<span class="token punctuation">)</span>
a<span class="token operator">:</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> MyState<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但这就要求我们对整个定义的类型做出声明，工作量非常大，而且未来你改一个函数，你还得改一遍类型，所有工作都 double 了，你愿意么？我肯定不愿意，那么怎么办呢？我希望 <code>defineStore</code> 来帮我完成这件事情，我希望我在调用他的时候自动帮我检测这些关键类型，在这里也就是 <code>state</code> 和 <code>commits</code> ，我们先来看 <code>state</code>：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Options<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  actions<span class="token operator">:</span> Record<span class="token operator">&lt;</span>
    <span class="token builtin">string</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span>commits<span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>
  <span class="token operator">&gt;</span><span class="token punctuation">;</span>
  commits<span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> State<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  state<span class="token operator">:</span> State<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">defineStore</span><span class="token generic class-name"><span class="token operator">&lt;</span>State<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>options<span class="token operator">:</span> Options<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> options<span class="token punctuation">;</span> <span class="token comment">// 你创建的store</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们为 <code>defineStore</code> 定义来一个 <code>State</code> 泛型，这样之后，你在定义 <code>commit</code> 的时候，你拿到的第一个参数 <code>state</code> 自动会推断出其类型，而这个类型的依据就是你传入的 <code>state</code> 的值。</p><p>注意: 你可以打开<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2F" target="_blank" rel="noopener noreferrer">TS Playground<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>把上面的代码复制进去看一下运行结果。</p><p>既然 <code>state</code> 可以这样，那么自然 <code>commits</code> 也可以，所以我们会得到以下的结果：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Options<span class="token operator">&lt;</span>
  State<span class="token punctuation">,</span>
  Commits <span class="token keyword">extends</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> State<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;</span></span>
<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  actions<span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>commits<span class="token operator">:</span> Commits<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  commits<span class="token operator">:</span> Commits<span class="token punctuation">;</span>
  state<span class="token operator">:</span> State<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> defineStore<span class="token operator">&lt;</span>
  State<span class="token punctuation">,</span>
  Commits <span class="token keyword">extends</span> <span class="token class-name">Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> State<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span> <span class="token keyword">void</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;</span><span class="token punctuation">(</span>options<span class="token operator">:</span> Options<span class="token operator">&lt;</span>State<span class="token punctuation">,</span> Commits<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> options<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">defineStore</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  actions<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>commits<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> commits<span class="token punctuation">.</span>a<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  commits<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>state<span class="token punctuation">,</span> newName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  state<span class="token operator">:</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">&#39;jokcy&#39;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是你实际运行这段代码时却会发现在 <code>actions</code> 里面并拿不到真正的 <code>commits</code> 而是 <code>Record&lt;string, ...&gt;</code> ，这里有一个很奇怪的问题，在得到答案之后会再继续更新。这个问题时可以解决的，怎么解决呢？只需要手动声明每个 <code>commit</code> 中的 <code>state</code> 的类型就可以了：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">State</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

commits<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> State<span class="token punctuation">,</span> newName<span class="token operator">:</span> stirng<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可以在 playground 尝试一下。这是目前一个可以接受的方案，因为我也会推荐你声明一下你的 <code>state</code> 类型，因为自动推断数据的类型经常不准，比如你直接写: <code>state: {arr: []}</code> ，你会得到 <code>never[]</code> 导致你无法修改 <code>arr</code> ，所以你肯定是要声明具体每个数组项的类型的。不论如何，定义的大头， <code>commits</code> 他肯定是帮我们省去了。</p><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><p>本文中我尽力为大家解释清楚 TS 中的类型推断（type infer）是怎么回事，我相信你自己尝试去理解一下把 TS 泛型类比函数的方式，一定会帮助你更好地理解。类型推断是非常重要的，如果你对于这一块不够理解，阅读 TS 代码就会比较困难，尤其是一些开源项目的定义，那是极其复杂的，各种泛型套泛型，所以即便你可能自己不会去写这么复杂的定义，推荐你至少对类型推断有一个总体的认知，防止在遇到类型问题时一脸懵逼。</p><p>另外推荐大家可以用一下 Discord，TS 官方有一个讨论组在上面，并且有专门的 help channel，你可以去提问，会有专门的人来回复你（当然你的英语也得过关，以及你一定要学会好的提问方式）。<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdiscord.gg%2Ftypescript" target="_blank" rel="noopener noreferrer">频道链接<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>。</p><p><a href="https://juejin.cn/post/7056750775749312548" target="_blank" rel="noopener noreferrer">查看原文 - Typescript重点之：理解类型推断<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><!-- https://juejin.cn/post/7056750775749312548 --></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: lisusheng@dycjr.com">susheng</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/ssVuePress/assets/app.4f2cb50a.js" defer></script>
  </body>
</html>
