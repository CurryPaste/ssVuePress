import{_ as e,o as c,c as d,e as a}from"./app.4f2cb50a.js";const o={},r=a('<h1 id="echarts-配置项" tabindex="-1"><a class="header-anchor" href="#echarts-配置项" aria-hidden="true">#</a> Echarts - 配置项</h1><blockquote><p>之前也用过几次echarts，对于配置项一直都是用到的时候再查，很多字段都是又熟悉又陌生。正好最近一直在做报表功能，借此总结一下经常会用的一些配置项</p></blockquote><h3 id="代码示例" tabindex="-1"><a class="header-anchor" href="#代码示例" aria-hidden="true">#</a> 代码示例</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code></code></pre><div class="line-numbers" aria-hidden="true"></div></div><h3 id="说一下几次做报表的感受" tabindex="-1"><a class="header-anchor" href="#说一下几次做报表的感受" aria-hidden="true">#</a> 说一下几次做报表的感受</h3><ul><li>最开始刚接触图表， 用了业界大哥 <code>echarts</code> 。技术栈<code>vue</code>，封装模式是<code>option</code>写死，通过 <code>props-echartsData</code> 传入 <code>series</code>，监听 <code>props</code>，调用 <code>setOption</code>。然后会有单独的函数处理<code>resize</code>。</li><li>21年接手了多个项目，有<code>echarts</code>的，有<code>g2</code>的，还有用<code>canvas</code>手动画的 (lll￢ω￢)。技术栈还是<code>vue</code>，封装模式类似，监听series的数据源，然后更新。这里提一下<code>g2</code>，使用感觉都大差不差，但是文档要比 <code>echarts</code>方便得多</li><li>22年再接触图表是移动端的，因为展示方式是webview，所以最后选型还是<code>echarts</code></li></ul>',6),s=[r];function t(i,n){return c(),d("div",null,s)}const l=e(o,[["render",t],["__file","index.html.vue"]]);export{l as default};
