import{_ as p,r as o,o as c,c as i,b as s,d as n,a as t,f as l,e}from"./app.4f2cb50a.js";const r={},u=e(`<h1 id="ts-类型推断" tabindex="-1"><a class="header-anchor" href="#ts-类型推断" aria-hidden="true">#</a> TS 类型推断</h1><p>在正式开始之前，先问一个问题，你知道在 Typescript（后面简称 TS）中有一个关键字用于推断类型么？是的这个关键字和本文的核心是一样的：<code>infer</code>。意如其字，<code>infer</code>就是推断，这个关键字就是用于推断类型。</p><h3 id="类型推断" tabindex="-1"><a class="header-anchor" href="#类型推断" aria-hidden="true">#</a> 类型推断</h3><p>类型推断在 TS 中其实无处不在，最简单的例子：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span> <span class="token comment">// typeof num === number</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在这里我们没有明确通过<code>const num: number</code>指定其类型，但是 TS 通过我们赋予其的初始值就可以确定其类型是 number，这就是最基础的类型推断。</p><p>同样如果我们声明一个函数：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// typeof num === number</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为我们的函数<code>fun</code>有明确的返回值<code>a + b</code>并且这两个参数都是<code>number</code>类型，可以明确确定函数的返回值就是<code>number</code>类型，所以即便我们没有明确写出<code>fun</code>的返回值<code>fun(): number</code>，但是 TS 会自动给我们推断出函数的返回类型是什么。</p><p>以上就是最基础的类型推断。</p><h3 id="infer-关键字" tabindex="-1"><a class="header-anchor" href="#infer-关键字" aria-hidden="true">#</a> infer 关键字</h3><p>那么既然 TS 已经这么强大能够推断出类型，那么为什么还需要<code>infer</code>关键字呢？答案就是，自动推断冉冉不够强大（废话）。毕竟编译器的能力仍然是有限的，不能指望所有情况都能帮助我们推断正确，尤其是 JS 这么灵活的语言，比如：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">logTuple</span><span class="token punctuation">(</span>tup<span class="token operator">:</span> <span class="token punctuation">{</span>tuple<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tup<span class="token punctuation">.</span>tuple<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tup<span class="token punctuation">.</span>tuple<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> myTuple <span class="token operator">=</span> <span class="token punctuation">{</span>tuple<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">logTuple</span><span class="token punctuation">(</span>myTuple<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>TS 会给我们一个错误.</p><p><code>Argument of type &#39;\\{ tuple: string[]; \\}&#39; is not assignable to parameter of type &#39;A&#39;.</code></p><p>这是因为在我们声明<code>myTuple</code>的时候，TS 就给我们推断了其类型，在 TS 眼中<code>[&#39;a&#39;, &#39;b&#39;]</code>对应的是<code>string[]</code>类型，而我们声明的<code>A</code>类型里面则对应的是<code>[string, string]</code>的<code>tuple</code>类型，所以这是无法对应上的。而直接<code>logTuple({tuple: [&#39;a&#39;, &#39;b&#39;]});</code>则又是可以的，这里就存在着参数类型推断的使用，我们会在后面的篇章中详细说，我们还是先关注失败的这种写法以及<code>infer</code>关键字。</p><p>那么这时候我们可以怎么解决这个问题呢？最简单的当然是把类型从参数中提出来，然后在声明<code>myTuple</code>的时候指定其类型来主动告知 TS：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  tuple<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> myTuple<span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">=</span> <span class="token punctuation">{</span>tuple<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">logTuple</span><span class="token punctuation">(</span>myTuple<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但这种方式有一个缺陷就是，如果logTuple函数并不是我们自己定义的，我们没法去修改其定义，那怎么办呢？</p><p>先直接说方案：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">GetFirstArgument<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>
  first<span class="token operator">:</span> <span class="token keyword">infer</span> FirstArgument<span class="token punctuation">,</span>
  <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span>
  <span class="token operator">?</span> FirstArgument
  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> myTuple<span class="token operator">:</span> GetFirstArgument<span class="token operator">&lt;</span><span class="token keyword">typeof</span> logTuple<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>tuple<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">logTuple</span><span class="token punctuation">(</span>myTuple<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这个工具类型，我们可以获取到<code>logTuple</code>的参数类型，进而指定<code>myTuple</code>为这个类型来解决这个问题。而这里我们就用到了<code>infer</code>这个关键字。那么事情是怎么发生的呢？</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">GetFirstArgument<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>
  first<span class="token operator">:</span> <span class="token keyword">infer</span> FirstArgument<span class="token punctuation">,</span>
  <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span>
  <span class="token operator">?</span> FirstArgument
  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>第一步：TS 判断我们赋予的 T 类型是否符合<code>extends</code>限定的类型，在这里是一个至少有一个参数的函数</li><li>第二步：一旦符合，则把这个 T 这个函数的第一个参数推断出来并且赋值给<code>FirstArgument</code></li><li>第三步：如果 T 符合该类型推断，则返回推断出来的<code>FirstArgument</code>类型，否则返回<code>never</code></li></ul>`,24),d={href:"https://link.juejin.cn/?target=https%3A%2F%2Fwww.coursebetter.com%2Ftools%2F2022%2Ftypescript-argument-type-inference",target:"_blank",rel:"noopener noreferrer"},k=e(`<p>这是一个极其典型的通过泛型来进行类型推断的例子，而<code>infer</code>关键字在这里的意义则是推断出<code>T</code>函数签名的第一个参数的类型，以及把这个类型赋值给<code>FirstArgument</code>以便后续使用。</p><p>需要注意的是，<code>FirstArgument</code>是有作用域的，他只会存在于<code>GetFirstArgument</code>的推断周期内，如果我们在其他地方定义了同名的<code>FirstArgument</code>，并不会影响这里的<code>FirstArgument</code>。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">FirstArgument</span><span class="token operator">=</span> <span class="token builtin">string</span>

<span class="token keyword">type</span> <span class="token class-name">GetFirstArgument<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>first<span class="token operator">:</span> <span class="token keyword">infer</span> FirstArgument<span class="token punctuation">,</span> <span class="token operator">...</span> <span class="token comment">// 没有任何关系</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你仍然不理解，你可以把<code>GetFirstArgument</code>看作一个函数：</p><ul><li><code>T</code>是他的参数</li><li>我们在使用<code>GetFirstArgument</code>类型时，其实就是调用了这个函数，然后传入了<code>logTuple</code>作为参数<code>T</code></li><li>然后得到的是<code>=</code>后面得到的类型，这段代码非常像我们在 JS 中二元判断，条件判断内容是<code>T</code>是否符合某个类型，在这里的类型是<code>(first: infer FirstArgument,...args: any[]) =&gt; any</code>，也就是一个至少有一个参数的函数</li><li>只要我们在使用<code>GetFirstArgument</code>时候给的是这样的一个函数，那么推断条件就成立，就会得到一个推断的<code>FirstArgument</code>类型然后作为结果返回，否则就返回二元判断的另外一个结果</li></ul><p>而这个 TS 的函数则是在：<code>const a: GetFirstArgument&lt;(a: number) =&gt; void&gt;</code>时调用（不是真的如 JS 函数一样调用，只是进行类比）。</p><h2 id="update-2" tabindex="-1"><a class="header-anchor" href="#update-2" aria-hidden="true">#</a> update-2</h2><h3 id="参数类型推断" tabindex="-1"><a class="header-anchor" href="#参数类型推断" aria-hidden="true">#</a> 参数类型推断</h3>`,8),v={href:"https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2F2%2Fgenerics.html",target:"_blank",rel:"noopener noreferrer"},m=e(`<p>我这里做一个最简单直观的介绍，我们直接用官方文档的例子：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">wrapper</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span>inner<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    inner<span class="token operator">:</span> arg<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如这个函数，他帮助我们把传入的参数外包了一层，使之变成了一个对象。在这个定义里面，我们的入参只能是 number 类型的，但是从函数实现上来说，我们其实并没必要把这个类型限制这么死，我门希望这个函数可以支持更多的类型。这里有很多解决方案，比如我们可以把我们能想象到的类型写到定义上：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">wrapper</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">number</span> ｜ <span class="token builtin">string</span> <span class="token operator">|</span> Date<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span> inner<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span> <span class="token operator">|</span> Date <span class="token punctuation">}</span> <span class="token punctuation">{</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是这并不是很好，因为每次我们希望增加一种类型的支持，都需要重新修改函数的定义，并且我们得到的返回值的<code>inner</code>类型是不确定的，不论我们最终传入的是<code>number</code>还是<code>string</code>，你得到的返回值的inner都是定义中的所有可能性。</p><p>而泛型则就是用来简单地解决这个问题的，我们来看看泛型的用法：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">wrapper</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span>inner<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    inner<span class="token operator">:</span> arg<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里我们对于函数的定义上增加了<code>&lt;T&gt;</code>，而他就是泛型的关键。当我们使用这个函数的时候就会变成这样：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token generic-function"><span class="token function">wrapper</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这时候 TS 的编译器就会知道，你这次调用<code>wrapper</code>函数传入的是<code>number</code>类型，所以这次函数调用的返回值也是<code>{inner: number}</code>。</p><p>泛型就类似于针对 TS 定义的参数，通过在调用时指定类型，来动态地应用类型于函数定义。就像我们在 JS 中，函数的参数可以控制函数的运行结果一样，所以让我用一句话来定义就是：针对 TS 定义的参数。</p><p>OK，泛型的基础用法和理解就讲到这里，更多的用法还是去看官方文档吧。</p><h3 id="参数类型推断-type-argument-inference" tabindex="-1"><a class="header-anchor" href="#参数类型推断-type-argument-inference" aria-hidden="true">#</a> 参数类型推断（type argument inference）</h3><p>那么接下去我们就来聊聊本文的另一个重点：参数类型推断。在 TS 中，类型推断时非常常见的，比如：</p><p>类型推断同样可是使用在函数的泛型定义中，比如上面的例子：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">wrapper</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span>inner<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    inner<span class="token operator">:</span> arg<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如若我们在使用时直接<code>wrapper(1)</code>，这个函数也能正常使用，并且 TS 也能识别出返回的类型是<code>{inner: number}</code>。在这个过程中，TS 首先发现我们传递给<code>wrapper</code>函数的参数是<code>1</code>，是个 number 类型。继而发现<code>wrapper</code>函数接受泛型，因为整个函数只有一个泛型而且和入参的类型时一致的，所以 TS 可以反推出<code>&lt;T&gt;</code>就是<code>number</code>类型。而这个过程是在<code>wrapper(1)</code>调用的时候确定的，所以就很类似 JS 的函数。</p><p>参数类型推断非常有用，尤其是当入参的类型非常复杂的时候。典型的例子是 vue3 的<code>defineComponent</code>函数。</p><p><code>defineComponent</code>用于定义一个组件，而组件定义的配置内容的类型时非常复杂的：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token function">defineComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    props<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们需要在使用该函数的时候把整个配置的内容都定义出来，那么我们的代码量可能需要增加一倍，并且整个学习难度也自然会上升一些，毕竟你需要记住这些参数的类型。</p><p>我们可以看一下\`defineComponeng 的定义：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">defineComponent</span><span class="token generic class-name"><span class="token operator">&lt;</span>
  PropsOptions <span class="token keyword">extends</span> Readonly<span class="token operator">&lt;</span>ComponentPropsOptions<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  RawBindings<span class="token punctuation">,</span>
  <span class="token constant">D</span><span class="token punctuation">,</span>
  <span class="token constant">C</span> <span class="token keyword">extends</span> ComputedOptions <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token constant">M</span> <span class="token keyword">extends</span> MethodOptions <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  Mixin <span class="token keyword">extends</span> ComponentOptionsMixin <span class="token operator">=</span> ComponentOptionsMixin<span class="token punctuation">,</span>
  Extends <span class="token keyword">extends</span> ComponentOptionsMixin <span class="token operator">=</span> ComponentOptionsMixin<span class="token punctuation">,</span>
  <span class="token constant">E</span> <span class="token keyword">extends</span> EmitsOptions <span class="token operator">=</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  <span class="token constant">EE</span> <span class="token keyword">extends</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token builtin">string</span>
<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>
  options<span class="token operator">:</span> ComponentOptionsWithObjectProps<span class="token operator">&lt;</span>
    PropsOptions<span class="token punctuation">,</span>
    RawBindings<span class="token punctuation">,</span>
    <span class="token constant">D</span><span class="token punctuation">,</span>
    <span class="token constant">C</span><span class="token punctuation">,</span>
    <span class="token constant">M</span><span class="token punctuation">,</span>
    Mixin<span class="token punctuation">,</span>
    Extends<span class="token punctuation">,</span>
    <span class="token constant">E</span><span class="token punctuation">,</span>
    <span class="token constant">EE</span>
  <span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token operator">:</span> DefineComponent<span class="token operator">&lt;</span>PropsOptions<span class="token punctuation">,</span> RawBindings<span class="token punctuation">,</span> <span class="token constant">D</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">,</span> <span class="token constant">M</span><span class="token punctuation">,</span> Mixin<span class="token punctuation">,</span> Extends<span class="token punctuation">,</span> <span class="token constant">E</span><span class="token punctuation">,</span> <span class="token constant">EE</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这还仅仅是一种函数签名，vue3 的<code>defineComponent</code>函数签名有 4 种 overrides，其复杂程度可想而知。索性有参数类型推断，让我们避免了每次使用都要写一堆复杂定义的烦恼。</p><p>我们只需要：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> Comp <span class="token operator">=</span> <span class="token function">defineComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> String<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们就知道<code>Comp</code>的 <code>props</code> 中有一个名为 <code>name</code> 的属性类型为 <code>String</code> 。</p><h3 id="extends" tabindex="-1"><a class="header-anchor" href="#extends" aria-hidden="true">#</a> extends</h3><p>我相信你已经注意到了在上面的 <code>defineComponents</code> 存在着非常多的 <code>extends</code> 。这又是 TS 中对于类型推断非常重要的一个字段。他的重要性体现在对鱼类型约束上。当你写 <code>function A&lt;T&gt;(opt: T): T</code> 的时候，这里的 <code>T</code> 可以是任意类型，所以你调用函数 <code>A(1)</code> 的时候， <code>T</code> 的类型又完全交还给 TS 来判断，比如之前的数组例子：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token constant">A</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>opt<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> opt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> tuple <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时候 <code>tuple</code> 会是 <code>string[]</code> 类型，而不是我们期望的 <code>[string, string]</code> 类型。这时候我们就可以给 <code>T</code> 一个约束：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token constant">A</span><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>opt<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> opt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> tuple <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时我们的 <code>tuple</code> 就会是 <code>[string, string]</code> ，我们给 <code>T</code> 约束为 <code>string</code> 类型的 tuple，TS 就会在类型推断的时候有限匹配约束的类型，如果类型无法匹配则会报错。</p><p>类型约束在类型推断中是非常有用的，事实上你应该尽量在使用泛型时赋予一个约束，这能够帮助我们更精确的得到自己想要的类型，你可以回过头去看 vue3 的 <code>difineComponent</code> ，几乎所有的泛型都是用 <code>extends</code> 来进行类型约束。</p><h3 id="实例讲解" tabindex="-1"><a class="header-anchor" href="#实例讲解" aria-hidden="true">#</a> 实例讲解</h3><p>最后我们通过一个例子再来展示一下参数类型推断的作用，假如有如下的场景：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">defineStore</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> options<span class="token punctuation">;</span> <span class="token comment">// 你创建的store</span>
<span class="token punctuation">}</span>

<span class="token function">defineStore</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  actions<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>commits<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> commits<span class="token punctuation">.</span>a<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  commits<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>state<span class="token punctuation">,</span> newName<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  state<span class="token operator">:</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">&#39;jokcy&#39;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们想要创建一个定义 <code>store</code> 的函数，这个定义比较类似 vuex，我们分成 <code>state/actions/commits</code> 三部分，在每个 <code>commit</code> 函数中我们会接收 <code>state</code> 作为第一个参数，便于我们更新数据；在每个 <code>action</code> 中我们接受所有 <code>commits</code> 作为参数，这样我们在 <code>action</code> 中可以进行数据更新。</p><p>那么为了更好的体验，我们自然希望每个 <code>commit</code> 中拿到的 <code>state</code> 可以知道其类型，同样在每个 <code>action</code> 中也知道所有 <code>commit</code> 的函数签名，这样我们调用 <code>commit</code> 的时候就知道要传哪些参数，TS 也可以帮我们在代码检测帮我们定为错误。我们可以这么做：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">MyCommits</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">MyState</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>

a<span class="token operator">:</span> <span class="token punctuation">(</span>commits<span class="token operator">:</span> MyCommits<span class="token punctuation">)</span>
a<span class="token operator">:</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> MyState<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但这就要求我们对整个定义的类型做出声明，工作量非常大，而且未来你改一个函数，你还得改一遍类型，所有工作都 double 了，你愿意么？我肯定不愿意，那么怎么办呢？我希望 <code>defineStore</code> 来帮我完成这件事情，我希望我在调用他的时候自动帮我检测这些关键类型，在这里也就是 <code>state</code> 和 <code>commits</code> ，我们先来看 <code>state</code>：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Options<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  actions<span class="token operator">:</span> Record<span class="token operator">&lt;</span>
    <span class="token builtin">string</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span>commits<span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>
  <span class="token operator">&gt;</span><span class="token punctuation">;</span>
  commits<span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> State<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  state<span class="token operator">:</span> State<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">defineStore</span><span class="token generic class-name"><span class="token operator">&lt;</span>State<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>options<span class="token operator">:</span> Options<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> options<span class="token punctuation">;</span> <span class="token comment">// 你创建的store</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们为 <code>defineStore</code> 定义来一个 <code>State</code> 泛型，这样之后，你在定义 <code>commit</code> 的时候，你拿到的第一个参数 <code>state</code> 自动会推断出其类型，而这个类型的依据就是你传入的 <code>state</code> 的值。</p>`,43),b={href:"https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2F",target:"_blank",rel:"noopener noreferrer"},g=e(`<p>既然 <code>state</code> 可以这样，那么自然 <code>commits</code> 也可以，所以我们会得到以下的结果：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Options<span class="token operator">&lt;</span>
  State<span class="token punctuation">,</span>
  Commits <span class="token keyword">extends</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> State<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;</span></span>
<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  actions<span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>commits<span class="token operator">:</span> Commits<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  commits<span class="token operator">:</span> Commits<span class="token punctuation">;</span>
  state<span class="token operator">:</span> State<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> defineStore<span class="token operator">&lt;</span>
  State<span class="token punctuation">,</span>
  Commits <span class="token keyword">extends</span> <span class="token class-name">Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> State<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span> <span class="token keyword">void</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;</span><span class="token punctuation">(</span>options<span class="token operator">:</span> Options<span class="token operator">&lt;</span>State<span class="token punctuation">,</span> Commits<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> options<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">defineStore</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  actions<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>commits<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> commits<span class="token punctuation">.</span>a<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  commits<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>state<span class="token punctuation">,</span> newName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  state<span class="token operator">:</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">&#39;jokcy&#39;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是你实际运行这段代码时却会发现在 <code>actions</code> 里面并拿不到真正的 <code>commits</code> 而是 <code>Record&lt;string, ...&gt;</code> ，这里有一个很奇怪的问题，在得到答案之后会再继续更新。这个问题时可以解决的，怎么解决呢？只需要手动声明每个 <code>commit</code> 中的 <code>state</code> 的类型就可以了：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">State</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

commits<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> State<span class="token punctuation">,</span> newName<span class="token operator">:</span> stirng<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可以在 playground 尝试一下。这是目前一个可以接受的方案，因为我也会推荐你声明一下你的 <code>state</code> 类型，因为自动推断数据的类型经常不准，比如你直接写: <code>state: {arr: []}</code> ，你会得到 <code>never[]</code> 导致你无法修改 <code>arr</code> ，所以你肯定是要声明具体每个数组项的类型的。不论如何，定义的大头， <code>commits</code> 他肯定是帮我们省去了。</p><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><p>本文中我尽力为大家解释清楚 TS 中的类型推断（type infer）是怎么回事，我相信你自己尝试去理解一下把 TS 泛型类比函数的方式，一定会帮助你更好地理解。类型推断是非常重要的，如果你对于这一块不够理解，阅读 TS 代码就会比较困难，尤其是一些开源项目的定义，那是极其复杂的，各种泛型套泛型，所以即便你可能自己不会去写这么复杂的定义，推荐你至少对类型推断有一个总体的认知，防止在遇到类型问题时一脸懵逼。</p>`,7),y={href:"https://link.juejin.cn/?target=https%3A%2F%2Fdiscord.gg%2Ftypescript",target:"_blank",rel:"noopener noreferrer"},f={href:"https://juejin.cn/post/7056750775749312548",target:"_blank",rel:"noopener noreferrer"};function h(w,T){const a=o("ExternalLinkIcon");return c(),i("div",null,[u,s("p",null,[n("点击"),s("a",d,[n("查看原文"),t(a)]),n("，原文这里有更丰富的组件进行代码讲解，更易于理解。")]),k,s("p",null,[n("在开始讲参数推断之前，我们需要至少对 TS 的泛型（generics）有基本的理解，推荐大家至少去官网看一下文档 ："),s("a",v,[n("文档地址"),t(a)]),n("。")]),m,s("p",null,[n("注意: 你可以打开"),s("a",b,[n("TS Playground"),t(a)]),n("把上面的代码复制进去看一下运行结果。")]),g,s("p",null,[n("另外推荐大家可以用一下 Discord，TS 官方有一个讨论组在上面，并且有专门的 help channel，你可以去提问，会有专门的人来回复你（当然你的英语也得过关，以及你一定要学会好的提问方式）。"),s("a",y,[n("频道链接"),t(a)]),n("。")]),s("p",null,[s("a",f,[n("查看原文 - Typescript重点之：理解类型推断"),t(a)])]),l(" https://juejin.cn/post/7056750775749312548 ")])}const S=p(r,[["render",h],["__file","index.html.vue"]]);export{S as default};
