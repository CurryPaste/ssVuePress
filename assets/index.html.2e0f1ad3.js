import{_ as o,r as h,o as n,c as s,b as e,d as t,a as d,e as a}from"./app.4f2cb50a.js";const l={},i=e("h1",{id:"_1-引言",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_1-引言","aria-hidden":"true"},"#"),t(" 1. 引言")],-1),c={href:"https://blog.logrocket.com/node-js-12/",target:"_blank",rel:"noopener noreferrer"},p=e("h1",{id:"_2-概述",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_2-概述","aria-hidden":"true"},"#"),t(" 2. 概述")],-1),_=e("p",null,"Node12 与以往的版本不同，带来了许多重大升级，包括更多 V8 特性，Http 解析速度的提升，启动速度的提升，更好的诊断报告、内置堆分析工具，ESM 模块的更新等。",-1),u=e("h2",{id:"v8-引擎升级",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#v8-引擎升级","aria-hidden":"true"},"#"),t(" V8 引擎升级")],-1),f=e("p",null,"V8 升级带来了如下几个特性：",-1),b={href:"https://v8.dev/blog/v8-release-72#async-stack-traces",target:"_blank",rel:"noopener noreferrer"},m={href:"https://v8.dev/blog/v8-release-74#faster-calls-with-arguments-mismatch",target:"_blank",rel:"noopener noreferrer"},k={href:"https://v8.dev/blog/v8-release-73#faster-await",target:"_blank",rel:"noopener noreferrer"},x={href:"https://v8.dev/blog/v8-release-72#javascript-parsing",target:"_blank",rel:"noopener noreferrer"},N=a('<p>可见 V8 引擎的升级不仅给 Node12 带来了福音，也会一定程度上提升网页的运行效率。</p><h2 id="tls-1-3-更好的安全性" tabindex="-1"><a class="header-anchor" href="#tls-1-3-更好的安全性" aria-hidden="true">#</a> TLS 1.3 更好的安全性</h2><p>随着 Node12 的发布，TLS 从 1.2 升级到了 1.3，更安全且更易配置。通过使用 TLS 1.3，Node 程序可以减少 Https 握手所需时间来提升请求性能。</p><h2 id="默认堆被正确配置了" tabindex="-1"><a class="header-anchor" href="#默认堆被正确配置了" aria-hidden="true">#</a> 默认堆被正确配置了</h2><p>以前默认堆大小需要通过 <code>-max-old-space-size</code> 设置，而且默认值是一个固定值，现在这个默认值可以根据可用内存动态分配，这样当内存较小时，Node 不会让内存移除而报错，而是主动终止自己的进程。</p><h2 id="默认的-http-解析器变为-llhttp" tabindex="-1"><a class="header-anchor" href="#默认的-http-解析器变为-llhttp" aria-hidden="true">#</a> 默认的 http 解析器变为 llhttp</h2>',6),g={href:"https://github.com/nodejs/http-parser",target:"_blank",rel:"noopener noreferrer"},E={href:"https://github.com/nodejs/llhttp#readme",target:"_blank",rel:"noopener noreferrer"},v=a('<h2 id="提供诊断报告" tabindex="-1"><a class="header-anchor" href="#提供诊断报告" aria-hidden="true">#</a> 提供诊断报告</h2><p>Node12 有一项实验功能，根据用户需求提供诊断报告，包括崩溃、性能下降、内存泄露、CPU 使用高等等。</p><h2 id="堆内存-dump" tabindex="-1"><a class="header-anchor" href="#堆内存-dump" aria-hidden="true">#</a> 堆内存 dump</h2><p>在以前，如果要将堆内存生成 dump 文件，需要在生产环境安装额外的模块，而 Node12 集成了这个功能。</p><h2 id="更好的原生模块支持" tabindex="-1"><a class="header-anchor" href="#更好的原生模块支持" aria-hidden="true">#</a> 更好的原生模块支持</h2>',5),S={href:"https://nodejs.org/api/n-api.html#n_api_n_api",target:"_blank",rel:"noopener noreferrer"},V=a('<table><thead><tr><th></th><th></th><th>JS 模块</th><th>原生拓展</th></tr></thead><tbody><tr><td>1.</td><td>... 需要编译</td><td>否</td><td>如果预编译了则不用</td></tr><tr><td>2.</td><td>... 是否可以运行在所有平台</td><td>是</td><td>如果预编译了则可以</td></tr><tr><td>3.</td><td>... 是否兼容所有 Node 版本</td><td>是</td><td>否</td></tr><tr><td>4.</td><td>... 会被加载多次</td><td>是</td><td>否</td></tr><tr><td>5.</td><td>... 如果没有明确使用多线程，则线程安全</td><td>是</td><td>否</td></tr><tr><td>6.</td><td>... 可以被销毁</td><td>是</td><td>否</td></tr></tbody></table><h2 id="worker-被正式启用了" tabindex="-1"><a class="header-anchor" href="#worker-被正式启用了" aria-hidden="true">#</a> Worker 被正式启用了</h2><p><code>--experimental-worker</code> 实验开关已取消，默认支持 <code>worker_threads</code>。</p><p>要注意的是，执行 CPU 密集型任务时适合用 worker（大量计算），而执行 I/O 密集型任务时，Worker 反而没有 Node 内置的 I/O 操作性能好（读写文件）。</p><h2 id="启动速度优化" tabindex="-1"><a class="header-anchor" href="#启动速度优化" aria-hidden="true">#</a> 启动速度优化</h2><p>通过在构建时提前为内置库生成代码缓存，最终使启动时间加快 30%。</p><h2 id="支持-es6-module" tabindex="-1"><a class="header-anchor" href="#支持-es6-module" aria-hidden="true">#</a> 支持 ES6 module</h2><p>Node12 对 ES6 module 的支持依然处于实验阶段，需要通过 <code>--experimental-modules</code> 开启。</p><p>简单来说，就是支持了 Import Export 语法，不需要再转成 <code>require</code> 了！如果在 <code>package.json</code> 增加 <code>&quot;type&quot;: &quot;module&quot;</code> 的配置，Node 将按照 ES6 module 方式处理。</p><h2 id="新的编译器和平台要求" tabindex="-1"><a class="header-anchor" href="#新的编译器和平台要求" aria-hidden="true">#</a> 新的编译器和平台要求</h2><p>由于升级到新的 V8 引擎以及内部改造，因此 Node12 在 Mac 与 Windows 之外的平台上，需要至少 GCC6 和 glibc 2.17。</p><h1 id="_3-精读" tabindex="-1"><a class="header-anchor" href="#_3-精读" aria-hidden="true">#</a> 3. 精读</h1><p>对于 V8 引擎升级、TLS 升级、堆配置自动化、http-parser 升级到 llhttp、启动速度优化都属于被动优化，代码无需改动，只要升级 Node 版本就可以享受。</p><p>支持 ES6 module 这个特性其实比较鸡肋，毕竟源码用 Ts 写的话，这些升级并不会对源码产生影响。</p><p><code>worker_threads</code> 可以被默认启用，就像以前支持 <code>async/await</code> 一样，会带来 Nodejs 多线程更广泛的使用。</p><p>Node12 更新了 V8 引擎，随着 V8 的更新，很多 ES 新规范也落地了，比如 Class 成员函数、私有成员变量等等。</p><h1 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结" aria-hidden="true">#</a> 4. 总结</h1><p>Nodejs 仅有 10 年历史，但现在越来越被开发者欢迎，因为它可以让 JS 运行在服务端，是扩大 JS 生态的重要一环。从 Node 更新历史中可以看到，性能和语法能力稳步提升，一些服务端环境需要的诊断报告、堆栈分析能力都在逐渐完善，社区上也有 Alinode 与 egg、express、koa 等好用的服务框架，相对于前端翻天覆地的变化，对 Node 的评价只有一个字：稳。</p>',18),w={href:"https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/113.%E7%B2%BE%E8%AF%BB%E3%80%8ANodejs%20V12%E3%80%8B.md",target:"_blank",rel:"noopener noreferrer"};function j(y,B){const r=h("ExternalLinkIcon");return n(),s("div",null,[i,e("p",null,[t("一起看看 "),e("a",c,[t("Nodejs 12"),d(r)]),t(" 带来了哪些改变。")]),p,_,u,f,e("ul",null,[e("li",null,[e("a",b,[t("zero-cost async 堆栈信息"),d(r)]),t(" 原生支持了 async 堆栈信息，不会添加额外运行时内容。")]),e("li",null,[e("a",m,[t("参数数量不匹配时性能优化"),d(r)]),t(" 即便参数传递多了或少了，现在都几乎不会影响 Node 的执行速度。")]),e("li",null,[e("a",k,[t("更快的 async"),d(r)]),t(" async /await 已经比 promises 快了两个 microticks。")]),e("li",null,[e("a",x,[t("更快的 Js 解析速度"),d(r)]),t(" 网页中的 V8 引擎一般花费 9.5% 时间在 JS 解析上，经过解析加速后，现在花费在 JS 解析上的时间降低到平均 7.5%。")])]),N,e("p",null,[t("nodejs 的 "),e("a",g,[t("http-parser"),d(r)]),t(" 已经非常难以维护和优化了，因此 "),e("a",E,[t("llhttp"),d(r)]),t(" 这个库，比 http-parser 快 156%，更重要的是，在 Node12 中，将默认解析器切换到了 llhttp。")]),v,e("p",null,[t("C++ 拓展 "),e("a",S,[t("N-API"),d(r)]),t(" 升级到版本 4，同时一个原生模块可以被 C++ 编写并发布到 npm，就像一个普通 JS 模块一样被引用。不过要注意一些区别：")]),V,e("p",null,[t("转载自 "),e("a",w,[t("ascoders/weekly"),d(r)])])])}const J=o(l,[["render",j],["__file","index.html.vue"]]);export{J as default};
